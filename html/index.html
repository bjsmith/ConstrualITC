<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
  <head>
    <title>groundup-online-itc-construal31 [PsychoPy]</title>
    <meta charset="UTF-8">
    <link href="js/vendors//jquery-ui-1.11.4.base/jquery-ui.min.css" rel="stylesheet">

    <style>
        /* project and resource dialogs */
        label, input { display:block; padding-bottom: .5em; }
        input.text { margin-bottom:1em; width:95%; padding: .5em; }
        fieldset { padding:0; border:0; margin-top:25px; }

        /* don't display close button in the top right corner of the box */
        .no-close .ui-dialog-titlebar-close { display: none; }
    </style>
  </head>

  <body>

    <!-- dialog place holder -->
    <div id="dialogDiv"/>

    <script type="text/javascript" src="js/vendors/Math2.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-ui-1.11.4.base/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery.blockUI.js" ></script>
    <script type="text/javascript" src="js/vendors/stats.min.js"></script>
    <script type="text/javascript" src="js/vendors/pixi.min.js"></script>
    <script type="text/javascript" src="js/vendors/papaparse.min.js"></script>
    <script type="text/javascript" src="js/vendors/preloadjs-0.6.2.min.js"></script>

    <script type="text/javascript" src="js/psychojs/main.js"></script>
    <script type="text/javascript" src="js/psychojs/core.js"></script>
    <script type="text/javascript" src="js/psychojs/data.js"></script>
    <script type="text/javascript" src="js/psychojs/events.js"></script>
    <script type="text/javascript" src="js/psychojs/gui.js"></script>
    <script type="text/javascript" src="js/psychojs/util.js"></script>
    <script type="text/javascript" src="js/psychojs/scheduler.js"></script>
    <script type="text/javascript" src="js/psychojs/visual.js"></script>
    <script type="text/javascript" src="js/psychojs/io.js"></script>
    <script type="text/javascript" src="js/psychojs/jamdb.js"></script>
    <script type="text/javascript" src="js/psychojs/colors.js"></script>
        <script type="text/javascript" src="js/psychojs/logging.js"></script>
    <script type="text/javascript" src="customjs/hypotheticality.js"></script>
	<script type="text/javascript" src="customjs/construal_itc_logic.js"></script>


    <script type='text/javascript'>
      // wait until document is ready:
      $(document).ready(function() {
        psychoJS.debug = true; //false;
        
        function setupExperiment() {
        
          // An ExperimentHandler isn't essential but helps with data saving
          thisExp = new psychoJS.data.ExperimentHandler({
              name: 'groundup-online-itc-construal31',
              version: '',
              extraInfo: expInfo,
              runtimeInfo: undefined,  // not yet supported by psychoJS
              originPath: undefined,  //not yet supported by psychoJS
              savePickle: true,       // not yet supported by psychoJS
              saveWideText: true,
              saveTo: 'EXPERIMENT_SERVER',
              /*dataFileName=filename*/});
        
          // setup resource manager:
          psychoJS.resourceManager.set({
                                win:win, downloadFrom:'EXPERIMENT_SERVER', projectId:undefined,
                                projectStatus:'PUBLIC', clock:new psychoJS.core.Clock()
                                });
        
          endExpNow = false; // flag for 'escape' or other condition => quit the exp
        
          // logging:
          psychoJS.logging.console.setLevel(psychoJS.logging.EXP);
          psychoJS.logging.server.set({'level':psychoJS.logging.EXP, 'saveTo':'EXPERIMENT_SERVER', 'experimentInfo': expInfo});
        
          return psychoJS.NEXT;
        }
        
        function updateInfo() {
          expInfo['date'] = psychoJS.data.getDateStr();  // add a simple timestamp
          expInfo['expName'] = expName;
        
          // store frame rate of monitor if we can measure it successfully
          expInfo['frameRate'] = win.getActualFrameRate();
          if (expInfo['frameRate'] != undefined) {
              frameDur = 1.0/Math.round(expInfo['frameRate']);
          }
          else {
              frameDur = 1.0/60.0; // couldn't get a reliable measure so guess
          }
        
          return psychoJS.NEXT;
        }
        
        function setupWin() {
          // Start Code - component code to be run before the window creation
          // Setup the Window
          win = new psychoJS.visual.Window({size:[1920, 1080],
              fullscr:true, screen:1.0,
              allowGUI:false, allowStencil:false,
              monitor:'testMonitor',
              color:[0,0,0], colorSpace:'rgb',
              blendMode:'avg',
              units:'use prefs'
              });
          return psychoJS.NEXT;
        }
        
        function experimentInit() {
          
          // Initialize components for Routine "beginRoutine"
          beginRoutineClock = new psychoJS.core.Clock();
          tLoading = new psychoJS.visual.TextStim({win : win, name : 'tLoading',
              text : '.......................',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          
          // Initialize components for Routine "fMRI_pause"
          fMRI_pauseClock = new psychoJS.core.Clock();
          BeginMomentarily = new psychoJS.visual.TextStim({win : win, name : 'BeginMomentarily',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          tPressToContinue = new psychoJS.visual.TextStim({win : win, name : 'tPressToContinue',
              text : 'Press 5 to continue.',
              font : 'Arial',
              pos : [0, -.9], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -2.0 
          });
          
          // Initialize components for Routine "rTaskInstructions"
          rTaskInstructionsClock = new psychoJS.core.Clock();
          task_instructions = new psychoJS.visual.TextStim({win : win, name : 'task_instructions',
              text : 'The game is starting.\n\nFor the money choice task, \nplease choose one of the two options on the screen.\n\nYou will have 5 seconds to make a decision.\n\nIf you are completing this in an fMRI scanner, \nplease remain as still as possible.\n\nPress 1 or 2 to continue.',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          debugtext = new psychoJS.visual.TextStim({win : win, name : 'debugtext',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0.5], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -1.0 
          });
          
          // Initialize components for Routine "rHowWhyTaskInstructions"
          rHowWhyTaskInstructionsClock = new psychoJS.core.Clock();
          iHowWhyTaskInstructions = new psychoJS.visual.ImageStim({
              win : win, name : 'iHowWhyTaskInstructions',
              image : 'sin', mask : undefined,
              ori : 0, pos : [0, 0], size : [2.0,2.0],
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : 0.0 
          });
          
          // Initialize components for Routine "rBlockInstructions"
          rBlockInstructionsClock = new psychoJS.core.Clock();
          tBlockInstructions = new psychoJS.visual.TextStim({win : win, name : 'tBlockInstructions',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          
          // Initialize components for Routine "ITIfix"
          ITIfixClock = new psychoJS.core.Clock();
          tFix = new psychoJS.visual.TextStim({win : win, name : 'tFix',
              text : '+',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          tITIFix_begin_code = new psychoJS.visual.TextStim({win : win, name : 'tITIFix_begin_code',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -1.0 
          });
          
          // Initialize components for Routine "construal_trial"
          construal_trialClock = new psychoJS.core.Clock();
          tConstrualQuestion = new psychoJS.visual.TextStim({win : win, name : 'tConstrualQuestion',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          tConstrualAnswer = new psychoJS.visual.TextStim({win : win, name : 'tConstrualAnswer',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -1.0 
          });
          yes1 = new psychoJS.visual.TextStim({win : win, name : 'yes1',
              text : '1\nYes',
              font : 'Arial',
              pos : [-0.3, -0.3], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -3.0 
          });
          no2 = new psychoJS.visual.TextStim({win : win, name : 'no2',
              text : '2\nNo',
              font : 'Arial',
              pos : [0.3, -0.3], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -4.0 
          });
          
          // Initialize components for Routine "rTaskInterval"
          rTaskIntervalClock = new psychoJS.core.Clock();
          tFixSimple = new psychoJS.visual.TextStim({win : win, name : 'tFixSimple',
              text : '+',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          tFixSimpleBeginCode = new psychoJS.visual.TextStim({win : win, name : 'tFixSimpleBeginCode',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -1.0 
          });
          
          // Initialize components for Routine "trial"
          trialClock = new psychoJS.core.Clock();
          iOption1Background = new psychoJS.visual.ImageStim({
              win : win, name : 'iOption1Background',
              image : 'sin', mask : undefined,
              ori : 0, pos : [-0.5, 0], size : [0.4, 0.3],
              color : 1.0, colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : 0.0 
          });
          iOption2Background = new psychoJS.visual.ImageStim({
              win : win, name : 'iOption2Background',
              image : 'sin', mask : undefined,
              ori : 0, pos : [0.5, 0], size : [0.4, 0.3],
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : -1.0 
          });
          delay1 = new psychoJS.visual.TextStim({win : win, name : 'delay1',
              text : 'default text',
              font : 'Arial',
              pos : [-0.5, -0.05], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -2.0 
          });
          delay2 = new psychoJS.visual.TextStim({win : win, name : 'delay2',
              text : 'default text',
              font : 'Arial',
              pos : [0.5, -0.05], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -3.0 
          });
          amount1 = new psychoJS.visual.TextStim({win : win, name : 'amount1',
              text : 'default text',
              font : 'Arial',
              pos : [-0.5, 0.05], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -4.0 
          });
          amount2 = new psychoJS.visual.TextStim({win : win, name : 'amount2',
              text : 'default text',
              font : 'Arial',
              pos : [0.5, 0.05], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -5.0 
          });
          divider = new psychoJS.visual.TextStim({win : win, name : 'divider',
              text : '|',
              font : 'Arial',
              pos : [0, 0], height : 0.2, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -6.0 
          });
          tRespondTooSlow = new psychoJS.visual.TextStim({win : win, name : 'tRespondTooSlow',
              text : 'Respond faster!',
              font : 'Arial',
              pos : [0, 0.3], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -8.0 
          });
          
          // Initialize components for Routine "finish_screen"
          finish_screenClock = new psychoJS.core.Clock();
          finishfix = new psychoJS.visual.TextStim({win : win, name : 'finishfix',
              text : '+',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          tKval = new psychoJS.visual.TextStim({win : win, name : 'tKval',
              text : 'default text',
              font : 'Arial',
              pos : [0, -0.6], height : 0.05, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -1.0 
          });
          tThanks = new psychoJS.visual.TextStim({win : win, name : 'tThanks',
              text : 'Thank you for your participation.',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -2.0 
          });
          tWarning = new psychoJS.visual.TextStim({win : win, name : 'tWarning',
              text : 'default text',
              font : 'Arial',
              pos : [0, -0.8], height : 0.05, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -3.0 
          });
          
          // Create some handy timers
          globalClock = new psychoJS.core.Clock();  // to track the time since experiment started
          routineTimer = new psychoJS.core.CountdownTimer();  // to track time remaining of each (non-slip) routine
          
          return psychoJS.NEXT;
        }
        
        function ITIfix2RoutineBegin() {
          //------Prepare to start Routine 'ITIfix2'-------
          t = 0;
          ITIfix2Clock.reset(); // clock
          frameN = -1;
          // update component parameters for each repeat
          tITIFix_begin_code2.setText(ITIFix_begin(2));
          // keep track of which components have finished
          ITIfix2Components = [];
          ITIfix2Components.push(tFix2);
          ITIfix2Components.push(tITIFix_begin_code2);
          for(var i = 0; i < ITIfix2Components.length; ++i) {
            thisComponent = ITIfix2Components[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
          }
          
          function ITIfix2RoutineEachFrame() {
            //------Loop for each frame of Routine 'ITIfix2'-------
            continueRoutine = true;
             // until we're told otherwise
            // get current time
            t = ITIfix2Clock.getTime();
            frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
            // update/draw components on each frame
            
            // *tFix2* updates
            if (t >= 0 && tFix2.status === psychoJS.NOT_STARTED) {
              // keep track of start time/frame for later
              tFix2.tStart = t;  // (not accounting for frame time here)
              tFix2.frameNStart = frameN;  // exact frame index
              tFix2.setAutoDraw(true);
            }
            
            // *tITIFix_begin_code2* updates
            if (t >= 1 && tITIFix_begin_code2.status === psychoJS.NOT_STARTED) {
              // keep track of start time/frame for later
              tITIFix_begin_code2.tStart = t;  // (not accounting for frame time here)
              tITIFix_begin_code2.frameNStart = frameN;  // exact frame index
              tITIFix_begin_code2.setAutoDraw(true);
            }
            frameRemains = 1 + 0 - frameDur * 0.75;  // most of one frame period left
            if (tITIFix_begin_code2.status === psychoJS.STARTED && t >= frameRemains) {
              tITIFix_begin_code2.setAutoDraw(false);
            }
            
            // check if the Routine should terminate
            if (!continueRoutine) {  // a component has requested a forced-end of Routine
              return psychoJS.NEXT;
            }
            continueRoutine = false;// reverts to True if at least one component still running
            for(var i = 0; i < ITIfix2Components.length; ++i) {
              thisComponent = ITIfix2Components[i];
              if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                continueRoutine = true;
                break;
              }
            }
            // check for quit (the Esc key)
            if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
              psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
            }
            
            // refresh the screen if continuing
            if (continueRoutine) {
              return psychoJS.FLIP_REPEAT;
            }
            else {
              return psychoJS.NEXT;
            }
          }
          
          function ITIfix2RoutineEnd() {
            //------Ending Routine 'ITIfix2'-------
            for (var i = 0; i < ITIfix2Components.length; ++i) {
              thisComponent = ITIfix2Components[i];
              if ("setAutoDraw" in thisComponent) {
                thisComponent.setAutoDraw(false);
              }
            }
            // the Routine "ITIfix2" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset();
            return psychoJS.NEXT;
          }
          
          function rTaskInstructionsRoutineBegin() {
            //------Prepare to start Routine 'rTaskInstructions'-------
            t = 0;
            rTaskInstructionsClock.reset(); // clock
            frameN = -1;
            // update component parameters for each repeat
            debugtext.setText(rTaskInstructionsClock.getTime());
            respTaskInstructions = new psychoJS.event.BuilderKeyResponse();
            // keep track of which components have finished
            rTaskInstructionsComponents = [];
            rTaskInstructionsComponents.push(task_instructions);
            rTaskInstructionsComponents.push(debugtext);
            rTaskInstructionsComponents.push(respTaskInstructions);
            for(var i = 0; i < rTaskInstructionsComponents.length; ++i) {
              thisComponent = rTaskInstructionsComponents[i];
              if ('status' in thisComponent) {
                thisComponent.status = psychoJS.NOT_STARTED;
              }
            }
            
            return psychoJS.NEXT;
            }
            
            function rTaskInstructionsRoutineEachFrame() {
              //------Loop for each frame of Routine 'rTaskInstructions'-------
              continueRoutine = true;
               // until we're told otherwise
              // get current time
              t = rTaskInstructionsClock.getTime();
              frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
              // update/draw components on each frame
              
              // *task_instructions* updates
              if (t >= 0.0 && task_instructions.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                task_instructions.tStart = t;  // (not accounting for frame time here)
                task_instructions.frameNStart = frameN;  // exact frame index
                task_instructions.setAutoDraw(true);
              }
              
              // *debugtext* updates
              if (t >= 0.0 && debugtext.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                debugtext.tStart = t;  // (not accounting for frame time here)
                debugtext.frameNStart = frameN;  // exact frame index
                debugtext.setAutoDraw(true);
              }
              
              // *respTaskInstructions* updates
              if (t >= 0 && respTaskInstructions.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                respTaskInstructions.tStart = t;  // (not accounting for frame time here)
                respTaskInstructions.frameNStart = frameN;  // exact frame index
                respTaskInstructions.status = psychoJS.STARTED;
                // keyboard checking is just starting
                respTaskInstructions.clock.reset();  // now t=0
                psychoJS.event.clearEvents({eventType:'keyboard'});
              }
              if (respTaskInstructions.status == psychoJS.STARTED) {
                theseKeys = psychoJS.event.getKeys({keyList:['1', '2']});
                
                // check for quit:
                if ("escape" in theseKeys) {
                    endExpNow = true;
                }
                if (theseKeys.length > 0) {  // at least one key was pressed
                  respTaskInstructions.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
                  respTaskInstructions.rt = respTaskInstructions.clock.getTime();
                  // a response ends the routine
                  continueRoutine = false;
                }
              }
              
              // check if the Routine should terminate
              if (!continueRoutine) {  // a component has requested a forced-end of Routine
                return psychoJS.NEXT;
              }
              continueRoutine = false;// reverts to True if at least one component still running
              for(var i = 0; i < rTaskInstructionsComponents.length; ++i) {
                thisComponent = rTaskInstructionsComponents[i];
                if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                  continueRoutine = true;
                  break;
                }
              }
              // check for quit (the Esc key)
              if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
              }
              
              // refresh the screen if continuing
              if (continueRoutine) {
                return psychoJS.FLIP_REPEAT;
              }
              else {
                return psychoJS.NEXT;
              }
            }
            
            function rTaskInstructionsRoutineEnd() {
              //------Ending Routine 'rTaskInstructions'-------
              for (var i = 0; i < rTaskInstructionsComponents.length; ++i) {
                thisComponent = rTaskInstructionsComponents[i];
                if ("setAutoDraw" in thisComponent) {
                  thisComponent.setAutoDraw(false);
                }
              }
              // check responses
              if (['', [], undefined].indexOf(respTaskInstructions.keys) >= 0) {    // No response was made
                  respTaskInstructions.keys = undefined;
              }
              thisExp.addData('respTaskInstructions.keys',respTaskInstructions.keys);
              if (respTaskInstructions.keys != undefined) {  // we had a response
                  thisExp.addData('respTaskInstructions.rt', respTaskInstructions.rt)
              }
              // the Routine "rTaskInstructions" was not non-slip safe, so reset the non-slip timer
              routineTimer.reset();
              return psychoJS.NEXT;
            }
            
            function k_valRoutineBegin() {
              //------Prepare to start Routine 'k_val'-------
              t = 0;
              k_valClock.reset(); // clock
              frameN = -1;
              // update component parameters for each repeat
              // keep track of which components have finished
              k_valComponents = [];
              for(var i = 0; i < k_valComponents.length; ++i) {
                thisComponent = k_valComponents[i];
                if ('status' in thisComponent) {
                  thisComponent.status = psychoJS.NOT_STARTED;
                }
              }
              
              return psychoJS.NEXT;
              }
              
              function k_valRoutineEachFrame() {
                //------Loop for each frame of Routine 'k_val'-------
                continueRoutine = true;
                 // until we're told otherwise
                // get current time
                t = k_valClock.getTime();
                frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                // update/draw components on each frame
                
                // check if the Routine should terminate
                if (!continueRoutine) {  // a component has requested a forced-end of Routine
                  return psychoJS.NEXT;
                }
                continueRoutine = false;// reverts to True if at least one component still running
                for(var i = 0; i < k_valComponents.length; ++i) {
                  thisComponent = k_valComponents[i];
                  if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                    continueRoutine = true;
                    break;
                  }
                }
                // check for quit (the Esc key)
                if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                  psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                }
                
                // refresh the screen if continuing
                if (continueRoutine) {
                  return psychoJS.FLIP_REPEAT;
                }
                else {
                  return psychoJS.NEXT;
                }
              }
              
              function k_valRoutineEnd() {
                //------Ending Routine 'k_val'-------
                for (var i = 0; i < k_valComponents.length; ++i) {
                  thisComponent = k_valComponents[i];
                  if ("setAutoDraw" in thisComponent) {
                    thisComponent.setAutoDraw(false);
                  }
                }
                // the Routine "k_val" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset();
                return psychoJS.NEXT;
              }
              
              function trialRoutineBegin() {
                //------Prepare to start Routine 'trial'-------
                t = 0;
                trialClock.reset(); // clock
                frameN = -1;
                // update component parameters for each repeat
                iOption1Background.setColor([1,1,1], colorSpace='rgb');
                iOption1Background.setImage(psychoJS.resourceManager.getResource('images/redbg.png'));
                iOption2Background.setImage(psychoJS.resourceManager.getResource('images/bluebg.png'));
                delay1.setText(SSamount);
                delay2.setText(LLdelay);
                amount1.setText(SSamount);
                amount2.setText(LLamount);
                resp_trial = new psychoJS.event.BuilderKeyResponse();
                // keep track of which components have finished
                trialComponents = [];
                trialComponents.push(iOption1Background);
                trialComponents.push(iOption2Background);
                trialComponents.push(delay1);
                trialComponents.push(delay2);
                trialComponents.push(amount1);
                trialComponents.push(amount2);
                trialComponents.push(divider);
                trialComponents.push(resp_trial);
                trialComponents.push(tRespondTooSlow);
                for(var i = 0; i < trialComponents.length; ++i) {
                  thisComponent = trialComponents[i];
                  if ('status' in thisComponent) {
                    thisComponent.status = psychoJS.NOT_STARTED;
                  }
                }
                
                                after_trialRoutineBegin();
                
                return psychoJS.NEXT;
                }
                
                function trialRoutineEachFrame() {
                  //------Loop for each frame of Routine 'trial'-------
                  continueRoutine = true;
                   // until we're told otherwise
                  // get current time
                  t = trialClock.getTime();
                  frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                  // update/draw components on each frame
                  
                  // *iOption1Background* updates
                  if (t >= 0.0 && iOption1Background.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    iOption1Background.tStart = t;  // (not accounting for frame time here)
                    iOption1Background.frameNStart = frameN;  // exact frame index
                    iOption1Background.setAutoDraw(true);
                  }
                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                  if (iOption1Background.status === psychoJS.STARTED && t >= frameRemains) {
                    iOption1Background.setAutoDraw(false);
                  }
                  
                  // *iOption2Background* updates
                  if (t >= 0.0 && iOption2Background.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    iOption2Background.tStart = t;  // (not accounting for frame time here)
                    iOption2Background.frameNStart = frameN;  // exact frame index
                    iOption2Background.setAutoDraw(true);
                  }
                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                  if (iOption2Background.status === psychoJS.STARTED && t >= frameRemains) {
                    iOption2Background.setAutoDraw(false);
                  }
                  
                  // *delay1* updates
                  if (t >= 0.0 && delay1.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    delay1.tStart = t;  // (not accounting for frame time here)
                    delay1.frameNStart = frameN;  // exact frame index
                    delay1.setAutoDraw(true);
                  }
                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                  if (delay1.status === psychoJS.STARTED && t >= frameRemains) {
                    delay1.setAutoDraw(false);
                  }
                  
                  // *delay2* updates
                  if (t >= 0.0 && delay2.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    delay2.tStart = t;  // (not accounting for frame time here)
                    delay2.frameNStart = frameN;  // exact frame index
                    delay2.setAutoDraw(true);
                  }
                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                  if (delay2.status === psychoJS.STARTED && t >= frameRemains) {
                    delay2.setAutoDraw(false);
                  }
                  
                  // *amount1* updates
                  if (t >= 0.0 && amount1.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    amount1.tStart = t;  // (not accounting for frame time here)
                    amount1.frameNStart = frameN;  // exact frame index
                    amount1.setAutoDraw(true);
                  }
                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                  if (amount1.status === psychoJS.STARTED && t >= frameRemains) {
                    amount1.setAutoDraw(false);
                  }
                  
                  // *amount2* updates
                  if (t >= 0.0 && amount2.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    amount2.tStart = t;  // (not accounting for frame time here)
                    amount2.frameNStart = frameN;  // exact frame index
                    amount2.setAutoDraw(true);
                  }
                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                  if (amount2.status === psychoJS.STARTED && t >= frameRemains) {
                    amount2.setAutoDraw(false);
                  }
                  
                  // *divider* updates
                  if (t >= 0.0 && divider.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    divider.tStart = t;  // (not accounting for frame time here)
                    divider.frameNStart = frameN;  // exact frame index
                    divider.setAutoDraw(true);
                  }
                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                  if (divider.status === psychoJS.STARTED && t >= frameRemains) {
                    divider.setAutoDraw(false);
                  }
                  
                  // *resp_trial* updates
                  if (t >= 0.0 && resp_trial.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    resp_trial.tStart = t;  // (not accounting for frame time here)
                    resp_trial.frameNStart = frameN;  // exact frame index
                    resp_trial.status = psychoJS.STARTED;
                    // keyboard checking is just starting
                    resp_trial.clock.reset();  // now t=0
                    psychoJS.event.clearEvents({eventType:'keyboard'});
                  }
                  if (resp_trial.status == psychoJS.STARTED) {
                    theseKeys = psychoJS.event.getKeys({keyList:['1', '2']});
                    
                    // check for quit:
                    if ("escape" in theseKeys) {
                        endExpNow = true;
                    }
                    if (theseKeys.length > 0) {  // at least one key was pressed
                      if (resp_trial.keys == []) {  // then this was the first keypress
                        resp_trial.keys = theseKeys[0]  // just the first key pressed
                        resp_trial.rt = resp_trial.clock.getTime();
                        // a response ends the routine
                        continueRoutine = false;
                      }
                    }
                  }
                  
                  // *tRespondTooSlow* updates
                  if (((showRespondFasterWarning)) && tRespondTooSlow.status === psychoJS.NOT_STARTED) {
                    // keep track of start time/frame for later
                    tRespondTooSlow.tStart = t;  // (not accounting for frame time here)
                    tRespondTooSlow.frameNStart = frameN;  // exact frame index
                    tRespondTooSlow.setAutoDraw(true);
                  }
                  if (tRespondTooSlow.status === psychoJS.STARTED && t >= (tRespondTooSlow.tStart + 1.0)) {
                    tRespondTooSlow.setAutoDraw(false);
                  }
                  
                  // check if the Routine should terminate
                  if (!continueRoutine) {  // a component has requested a forced-end of Routine
                    return psychoJS.NEXT;
                  }
                  continueRoutine = false;// reverts to True if at least one component still running
                  for(var i = 0; i < trialComponents.length; ++i) {
                    thisComponent = trialComponents[i];
                    if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                      continueRoutine = true;
                      break;
                    }
                  }
                  // check for quit (the Esc key)
                  if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                    psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                  }
                  
                  					after_TrialRoutineEachFrame();
                  // refresh the screen if continuing
                  if (continueRoutine) {
                    return psychoJS.FLIP_REPEAT;
                  }
                  else {
                    return psychoJS.NEXT;
                  }
                }
                
                function trialRoutineEnd() {


                  //------Ending Routine 'trial'-------
                  for (var i = 0; i < trialComponents.length; ++i) {
                    thisComponent = trialComponents[i];
                    if ("setAutoDraw" in thisComponent) {
                      thisComponent.setAutoDraw(false);
                    }
                  }
                  // check responses
                  if (['', [], undefined].indexOf(resp_trial.keys) >= 0) {    // No response was made
                      resp_trial.keys = undefined;
                  }
                  thisExp.addData('resp_trial.keys',resp_trial.keys);
                  if (resp_trial.keys != undefined) {  // we had a response
                      thisExp.addData('resp_trial.rt', resp_trial.rt)
                  }
                  // the Routine "trial" was not non-slip safe, so reset the non-slip timer
                  routineTimer.reset();
                  return psychoJS.NEXT;
                }
                
                function rBlockInstructionsRoutineBegin() {
                  //------Prepare to start Routine 'rBlockInstructions'-------
                  t = 0;
                  rBlockInstructionsClock.reset(); // clock
                  frameN = -1;
                  routineTimer.add(10.000000);
                  // update component parameters for each repeat
                  tBlockInstructions.setText(PreTaskInstructions.replaceAll("\\n","\n"));
                  // keep track of which components have finished
                  rBlockInstructionsComponents = [];
                  rBlockInstructionsComponents.push(tBlockInstructions);
                  for(var i = 0; i < rBlockInstructionsComponents.length; ++i) {
                    thisComponent = rBlockInstructionsComponents[i];
                    if ('status' in thisComponent) {
                      thisComponent.status = psychoJS.NOT_STARTED;
                    }
                  }
                  
                  return psychoJS.NEXT;
                  }
                  
                  function rBlockInstructionsRoutineEachFrame() {
                    //------Loop for each frame of Routine 'rBlockInstructions'-------
                    continueRoutine = true;
                     // until we're told otherwise
                    // get current time
                    t = rBlockInstructionsClock.getTime();
                    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                    // update/draw components on each frame
                    
                    // *tBlockInstructions* updates
                    if (t >= 0 && tBlockInstructions.status === psychoJS.NOT_STARTED) {
                      // keep track of start time/frame for later
                      tBlockInstructions.tStart = t;  // (not accounting for frame time here)
                      tBlockInstructions.frameNStart = frameN;  // exact frame index
                      tBlockInstructions.setAutoDraw(true);
                    }
                    frameRemains = 0 + 10 - frameDur * 0.75;  // most of one frame period left
                    if (tBlockInstructions.status === psychoJS.STARTED && t >= frameRemains) {
                      tBlockInstructions.setAutoDraw(false);
                    }
                    
                    // check if the Routine should terminate
                    if (!continueRoutine) {  // a component has requested a forced-end of Routine
                      return psychoJS.NEXT;
                    }
                    continueRoutine = false;// reverts to True if at least one component still running
                    for(var i = 0; i < rBlockInstructionsComponents.length; ++i) {
                      thisComponent = rBlockInstructionsComponents[i];
                      if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                        continueRoutine = true;
                        break;
                      }
                    }
                    // check for quit (the Esc key)
                    if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                      psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                    }
                    
                    // refresh the screen if continuing
                    if (continueRoutine && routineTimer.getTime() > 0) {
                      return psychoJS.FLIP_REPEAT;
                    }
                    else {
                      return psychoJS.NEXT;
                    }
                  }
                  
                  function rBlockInstructionsRoutineEnd() {
                    //------Ending Routine 'rBlockInstructions'-------
                    for (var i = 0; i < rBlockInstructionsComponents.length; ++i) {
                      thisComponent = rBlockInstructionsComponents[i];
                      if ("setAutoDraw" in thisComponent) {
                        thisComponent.setAutoDraw(false);
                      }
                    }
                    return psychoJS.NEXT;
                  }
                  
                  function fMRI_pauseRoutineBegin() {
                    //------Prepare to start Routine 'fMRI_pause'-------
                    t = 0;
                    fMRI_pauseClock.reset(); // clock
                    frameN = -1;
                    // update component parameters for each repeat
                    BeginMomentarily.setText(BeginMomentarily_getText());
                    resp_fMRI = new psychoJS.event.BuilderKeyResponse();
                    // keep track of which components have finished
                    fMRI_pauseComponents = [];
                    fMRI_pauseComponents.push(BeginMomentarily);
                    fMRI_pauseComponents.push(resp_fMRI);
                    fMRI_pauseComponents.push(tPressToContinue);
                    for(var i = 0; i < fMRI_pauseComponents.length; ++i) {
                      thisComponent = fMRI_pauseComponents[i];
                      if ('status' in thisComponent) {
                        thisComponent.status = psychoJS.NOT_STARTED;
                      }
                    }
                    
                    return psychoJS.NEXT;
                    }
                    
                    function fMRI_pauseRoutineEachFrame() {
                      //------Loop for each frame of Routine 'fMRI_pause'-------
                      continueRoutine = true;
                       // until we're told otherwise
                      // get current time
                      t = fMRI_pauseClock.getTime();
                      frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                      // update/draw components on each frame
                      
                      // *BeginMomentarily* updates
                      if (t >= 0.0 && BeginMomentarily.status === psychoJS.NOT_STARTED) {
                        // keep track of start time/frame for later
                        BeginMomentarily.tStart = t;  // (not accounting for frame time here)
                        BeginMomentarily.frameNStart = frameN;  // exact frame index
                        BeginMomentarily.setAutoDraw(true);
                      }
                      
                      // *resp_fMRI* updates
                      if (t >= 0.0 && resp_fMRI.status === psychoJS.NOT_STARTED) {
                        // keep track of start time/frame for later
                        resp_fMRI.tStart = t;  // (not accounting for frame time here)
                        resp_fMRI.frameNStart = frameN;  // exact frame index
                        resp_fMRI.status = psychoJS.STARTED;
                        // keyboard checking is just starting
                        resp_fMRI.clock.reset();  // now t=0
                        psychoJS.event.clearEvents({eventType:'keyboard'});
                      }
                      if (resp_fMRI.status == psychoJS.STARTED) {
                        theseKeys = psychoJS.event.getKeys({keyList:['5']});
                        
                        // check for quit:
                        if ("escape" in theseKeys) {
                            endExpNow = true;
                        }
                        if (theseKeys.length > 0) {  // at least one key was pressed
                          resp_fMRI.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
                          resp_fMRI.rt = resp_fMRI.clock.getTime();
                          // a response ends the routine
                          continueRoutine = false;
                        }
                      }
                      
                      // *tPressToContinue* updates
                      if (((expInfo['run'].toLowerCase().startsWith('p'))) && tPressToContinue.status === psychoJS.NOT_STARTED) {
                        // keep track of start time/frame for later
                        tPressToContinue.tStart = t;  // (not accounting for frame time here)
                        tPressToContinue.frameNStart = frameN;  // exact frame index
                        tPressToContinue.setAutoDraw(true);
                      }
                      
                      // check if the Routine should terminate
                      if (!continueRoutine) {  // a component has requested a forced-end of Routine
                        return psychoJS.NEXT;
                      }
                      continueRoutine = false;// reverts to True if at least one component still running
                      for(var i = 0; i < fMRI_pauseComponents.length; ++i) {
                        thisComponent = fMRI_pauseComponents[i];
                        if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                          continueRoutine = true;
                          break;
                        }
                      }
                      // check for quit (the Esc key)
                      if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                        psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                      }
                      
                      // refresh the screen if continuing
                      if (continueRoutine) {
                        return psychoJS.FLIP_REPEAT;
                      }
                      else {
                        return psychoJS.NEXT;
                      }
                    }
                    
                    function fMRI_pauseRoutineEnd() {
                      //------Ending Routine 'fMRI_pause'-------
                      for (var i = 0; i < fMRI_pauseComponents.length; ++i) {
                        thisComponent = fMRI_pauseComponents[i];
                        if ("setAutoDraw" in thisComponent) {
                          thisComponent.setAutoDraw(false);
                        }
                      }
                      // check responses
                      if (['', [], undefined].indexOf(resp_fMRI.keys) >= 0) {    // No response was made
                          resp_fMRI.keys = undefined;
                      }
                      thisExp.addData('resp_fMRI.keys',resp_fMRI.keys);
                      if (resp_fMRI.keys != undefined) {  // we had a response
                          thisExp.addData('resp_fMRI.rt', resp_fMRI.rt)
                      }
                      // the Routine "fMRI_pause" was not non-slip safe, so reset the non-slip timer
                      routineTimer.reset();
                      return psychoJS.NEXT;
                    }
                    
                    function rTaskIntervalRoutineBegin() {
                      //------Prepare to start Routine 'rTaskInterval'-------
                      t = 0;
                      rTaskIntervalClock.reset(); // clock
                      frameN = -1;
                      // update component parameters for each repeat
                      tFixSimpleBeginCode.setText(on_rTaskIntervalFrame());
                      // keep track of which components have finished
                      rTaskIntervalComponents = [];
                      rTaskIntervalComponents.push(tFixSimple);
                      rTaskIntervalComponents.push(tFixSimpleBeginCode);
                      for(var i = 0; i < rTaskIntervalComponents.length; ++i) {
                        thisComponent = rTaskIntervalComponents[i];
                        if ('status' in thisComponent) {
                          thisComponent.status = psychoJS.NOT_STARTED;
                        }
                      }
                      
                      return psychoJS.NEXT;
                      }
                      
                      function rTaskIntervalRoutineEachFrame() {
                        //------Loop for each frame of Routine 'rTaskInterval'-------
                        continueRoutine = true;
                         // until we're told otherwise
                        // get current time
                        t = rTaskIntervalClock.getTime();
                        frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                        // update/draw components on each frame
                        
                        // *tFixSimple* updates
                        if (t >= 0.0 && tFixSimple.status === psychoJS.NOT_STARTED) {
                          // keep track of start time/frame for later
                          tFixSimple.tStart = t;  // (not accounting for frame time here)
                          tFixSimple.frameNStart = frameN;  // exact frame index
                          tFixSimple.setAutoDraw(true);
                        }
                        
                        // *tFixSimpleBeginCode* updates
                        if (t >= 0.0 && tFixSimpleBeginCode.status === psychoJS.NOT_STARTED) {
                          // keep track of start time/frame for later
                          tFixSimpleBeginCode.tStart = t;  // (not accounting for frame time here)
                          tFixSimpleBeginCode.frameNStart = frameN;  // exact frame index
                          tFixSimpleBeginCode.setAutoDraw(true);
                        }
                        
                        // check if the Routine should terminate
                        if (!continueRoutine) {  // a component has requested a forced-end of Routine
                          return psychoJS.NEXT;
                        }
                        continueRoutine = false;// reverts to True if at least one component still running
                        for(var i = 0; i < rTaskIntervalComponents.length; ++i) {
                          thisComponent = rTaskIntervalComponents[i];
                          if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                            continueRoutine = true;
                            break;
                          }
                        }
                        // check for quit (the Esc key)
                        if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                          psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                        }
                        
                                          after_rTaskIntervalRoutineEachFrame();
                  // refresh the screen if continuing
                  if (continueRoutine) {
                    return psychoJS.FLIP_REPEAT;
                  }
                  else {
                    return psychoJS.NEXT;
                  }
                }
                
                function rTaskIntervalRoutineEnd() {
                        //------Ending Routine 'rTaskInterval'-------
                        for (var i = 0; i < rTaskIntervalComponents.length; ++i) {
                          thisComponent = rTaskIntervalComponents[i];
                          if ("setAutoDraw" in thisComponent) {
                            thisComponent.setAutoDraw(false);
                          }
                        }
                        // the Routine "rTaskInterval" was not non-slip safe, so reset the non-slip timer
                        routineTimer.reset();
                        return psychoJS.NEXT;
                      }
                      
                      function rTaskInterval2RoutineBegin() {
                        //------Prepare to start Routine 'rTaskInterval2'-------
                        t = 0;
                        rTaskInterval2Clock.reset(); // clock
                        frameN = -1;
                        // update component parameters for each repeat
                        // keep track of which components have finished
                        rTaskInterval2Components = [];
                        rTaskInterval2Components.push(tFixSimple2);
                        rTaskInterval2Components.push(tFixSimpleBeginCode2);
                        for(var i = 0; i < rTaskInterval2Components.length; ++i) {
                          thisComponent = rTaskInterval2Components[i];
                          if ('status' in thisComponent) {
                            thisComponent.status = psychoJS.NOT_STARTED;
                          }
                        }
                        
                        return psychoJS.NEXT;
                        }
                        
                        function rTaskInterval2RoutineEachFrame() {
                          //------Loop for each frame of Routine 'rTaskInterval2'-------
                          continueRoutine = true;
                           // until we're told otherwise
                          // get current time
                          t = rTaskInterval2Clock.getTime();
                          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                          // update/draw components on each frame
                          
                          // *tFixSimple2* updates
                          if (t >= 0 && tFixSimple2.status === psychoJS.NOT_STARTED) {
                            // keep track of start time/frame for later
                            tFixSimple2.tStart = t;  // (not accounting for frame time here)
                            tFixSimple2.frameNStart = frameN;  // exact frame index
                            tFixSimple2.setAutoDraw(true);
                          }
                          
                          // *tFixSimpleBeginCode2* updates
                          if (t >= 0.0 && tFixSimpleBeginCode2.status === psychoJS.NOT_STARTED) {
                            // keep track of start time/frame for later
                            tFixSimpleBeginCode2.tStart = t;  // (not accounting for frame time here)
                            tFixSimpleBeginCode2.frameNStart = frameN;  // exact frame index
                            tFixSimpleBeginCode2.setAutoDraw(true);
                          }
                          
                          // check if the Routine should terminate
                          if (!continueRoutine) {  // a component has requested a forced-end of Routine
                            return psychoJS.NEXT;
                          }
                          continueRoutine = false;// reverts to True if at least one component still running
                          for(var i = 0; i < rTaskInterval2Components.length; ++i) {
                            thisComponent = rTaskInterval2Components[i];
                            if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                              continueRoutine = true;
                              break;
                            }
                          }
                          // check for quit (the Esc key)
                          if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                            psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                          }
                          
                          // refresh the screen if continuing
                          if (continueRoutine) {
                            return psychoJS.FLIP_REPEAT;
                          }
                          else {
                            return psychoJS.NEXT;
                          }
                        }
                        
                        function rTaskInterval2RoutineEnd() {
                          //------Ending Routine 'rTaskInterval2'-------
                          for (var i = 0; i < rTaskInterval2Components.length; ++i) {
                            thisComponent = rTaskInterval2Components[i];
                            if ("setAutoDraw" in thisComponent) {
                              thisComponent.setAutoDraw(false);
                            }
                          }
                          // the Routine "rTaskInterval2" was not non-slip safe, so reset the non-slip timer
                          routineTimer.reset();
                          return psychoJS.NEXT;
                        }
                        
                        function ITIfixRoutineBegin() {
                          //------Prepare to start Routine 'ITIfix'-------
                          t = 0;
                          ITIfixClock.reset(); // clock
                          frameN = -1;
                          // update component parameters for each repeat
                          tITIFix_begin_code.setText(ITIFix_begin());
                          // keep track of which components have finished
                          ITIfixComponents = [];
                          ITIfixComponents.push(tFix);
                          ITIfixComponents.push(tITIFix_begin_code);
                          for(var i = 0; i < ITIfixComponents.length; ++i) {
                            thisComponent = ITIfixComponents[i];
                            if ('status' in thisComponent) {
                              thisComponent.status = psychoJS.NOT_STARTED;
                            }
                          }
                          
                          return psychoJS.NEXT;
                          }
                          
                          function ITIfixRoutineEachFrame() {
                            //------Loop for each frame of Routine 'ITIfix'-------
                            continueRoutine = true;
                             // until we're told otherwise
                            // get current time
                            t = ITIfixClock.getTime();
                            frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                            // update/draw components on each frame
                            
                            // *tFix* updates
                            if (t >= 0 && tFix.status === psychoJS.NOT_STARTED) {
                              // keep track of start time/frame for later
                              tFix.tStart = t;  // (not accounting for frame time here)
                              tFix.frameNStart = frameN;  // exact frame index
                              tFix.setAutoDraw(true);
                            }
                            
                            // *tITIFix_begin_code* updates
                            if (t >= 0.0 && tITIFix_begin_code.status === psychoJS.NOT_STARTED) {
                              // keep track of start time/frame for later
                              tITIFix_begin_code.tStart = t;  // (not accounting for frame time here)
                              tITIFix_begin_code.frameNStart = frameN;  // exact frame index
                              tITIFix_begin_code.setAutoDraw(true);
                            }
                            
                            // check if the Routine should terminate
                            if (!continueRoutine) {  // a component has requested a forced-end of Routine
                              return psychoJS.NEXT;
                            }
                            continueRoutine = false;// reverts to True if at least one component still running
                            for(var i = 0; i < ITIfixComponents.length; ++i) {
                              thisComponent = ITIfixComponents[i];
                              if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                continueRoutine = true;
                                break;
                              }
                            }
                            // check for quit (the Esc key)
                            if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                              psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                            }
                            
                                              after_ITIfixRoutineEachFrame();
                  // refresh the screen if continuing
                  if (continueRoutine) {
                    return psychoJS.FLIP_REPEAT;
                  }
                  else {
                    return psychoJS.NEXT;
                  }
                }
                
                function ITIfixRoutineEnd() {
                            //------Ending Routine 'ITIfix'-------
                            for (var i = 0; i < ITIfixComponents.length; ++i) {
                              thisComponent = ITIfixComponents[i];
                              if ("setAutoDraw" in thisComponent) {
                                thisComponent.setAutoDraw(false);
                              }
                            }
                            // the Routine "ITIfix" was not non-slip safe, so reset the non-slip timer
                            routineTimer.reset();
                            return psychoJS.NEXT;
                          }
                          
                          function finish_screenRoutineBegin() {
                            //------Prepare to start Routine 'finish_screen'-------
                            t = 0;
                            finish_screenClock.reset(); // clock
                            frameN = -1;
                            // update component parameters for each repeat
                            tKval.setText(Math.round(k_val[0]*Math.pow(10,4))/Math.pow(10,4)+", " + Math.round(k_val[1]*Math.pow(10,4))/Math.pow(10,4));
                            tWarning.setText(tGetWarningText());
                            finish_screen_end_response = new psychoJS.event.BuilderKeyResponse();
                            // keep track of which components have finished
                            finish_screenComponents = [];
                            finish_screenComponents.push(finishfix);
                            finish_screenComponents.push(tKval);
                            finish_screenComponents.push(tThanks);
                            finish_screenComponents.push(tWarning);
                            finish_screenComponents.push(finish_screen_end_response);
                            for(var i = 0; i < finish_screenComponents.length; ++i) {
                              thisComponent = finish_screenComponents[i];
                              if ('status' in thisComponent) {
                                thisComponent.status = psychoJS.NOT_STARTED;
                              }
                            }
                            
                            return psychoJS.NEXT;
                            }
                            
                            function finish_screenRoutineEachFrame() {
                              //------Loop for each frame of Routine 'finish_screen'-------
                              continueRoutine = true;
                               // until we're told otherwise
                              // get current time
                              t = finish_screenClock.getTime();
                              frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                              // update/draw components on each frame
                              
                              // *finishfix* updates
                              if (t >= 0.0 && finishfix.status === psychoJS.NOT_STARTED) {
                                // keep track of start time/frame for later
                                finishfix.tStart = t;  // (not accounting for frame time here)
                                finishfix.frameNStart = frameN;  // exact frame index
                                finishfix.setAutoDraw(true);
                              }
                              frameRemains = 0.0 + 12 - frameDur * 0.75;  // most of one frame period left
                              if (finishfix.status === psychoJS.STARTED && t >= frameRemains) {
                                finishfix.setAutoDraw(false);
                              }
                              
                              // *tKval* updates
                              if (t >= 0.0 && tKval.status === psychoJS.NOT_STARTED) {
                                // keep track of start time/frame for later
                                tKval.tStart = t;  // (not accounting for frame time here)
                                tKval.frameNStart = frameN;  // exact frame index
                                tKval.setAutoDraw(true);
                              }
                              
                              // *tThanks* updates
                              if (t >= 12 && tThanks.status === psychoJS.NOT_STARTED) {
                                // keep track of start time/frame for later
                                tThanks.tStart = t;  // (not accounting for frame time here)
                                tThanks.frameNStart = frameN;  // exact frame index
                                tThanks.setAutoDraw(true);
                              }
                              
                              // *tWarning* updates
                              if (t >= 12 && tWarning.status === psychoJS.NOT_STARTED) {
                                // keep track of start time/frame for later
                                tWarning.tStart = t;  // (not accounting for frame time here)
                                tWarning.frameNStart = frameN;  // exact frame index
                                tWarning.setAutoDraw(true);
                              }
                              
                              // *finish_screen_end_response* updates
                              if (t >= 12 && finish_screen_end_response.status === psychoJS.NOT_STARTED) {
                                // keep track of start time/frame for later
                                finish_screen_end_response.tStart = t;  // (not accounting for frame time here)
                                finish_screen_end_response.frameNStart = frameN;  // exact frame index
                                finish_screen_end_response.status = psychoJS.STARTED;
                                // keyboard checking is just starting
                                finish_screen_end_response.clock.reset();  // now t=0
                                psychoJS.event.clearEvents({eventType:'keyboard'});
                              }
                              if (finish_screen_end_response.status == psychoJS.STARTED) {
                                theseKeys = psychoJS.event.getKeys({keyList:['space']});
                                
                                // check for quit:
                                if ("escape" in theseKeys) {
                                    endExpNow = true;
                                }
                                if (theseKeys.length > 0) {  // at least one key was pressed
                                  finish_screen_end_response.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
                                  finish_screen_end_response.rt = finish_screen_end_response.clock.getTime();
                                  // a response ends the routine
                                  continueRoutine = false;
                                }
                              }
                              
                              // check if the Routine should terminate
                              if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                return psychoJS.NEXT;
                              }
                              continueRoutine = false;// reverts to True if at least one component still running
                              for(var i = 0; i < finish_screenComponents.length; ++i) {
                                thisComponent = finish_screenComponents[i];
                                if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                  continueRoutine = true;
                                  break;
                                }
                              }
                              // check for quit (the Esc key)
                              if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                              }
                              
                              // refresh the screen if continuing
                              if (continueRoutine) {
                                return psychoJS.FLIP_REPEAT;
                              }
                              else {
                                return psychoJS.NEXT;
                              }
                            }
                            
                            function finish_screenRoutineEnd() {
                              //------Ending Routine 'finish_screen'-------
                              for (var i = 0; i < finish_screenComponents.length; ++i) {
                                thisComponent = finish_screenComponents[i];
                                if ("setAutoDraw" in thisComponent) {
                                  thisComponent.setAutoDraw(false);
                                }
                              }
                              // check responses
                              if (['', [], undefined].indexOf(finish_screen_end_response.keys) >= 0) {    // No response was made
                                  finish_screen_end_response.keys = undefined;
                              }
                              thisExp.addData('finish_screen_end_response.keys',finish_screen_end_response.keys);
                              if (finish_screen_end_response.keys != undefined) {  // we had a response
                                  thisExp.addData('finish_screen_end_response.rt', finish_screen_end_response.rt)
                              }
                              // the Routine "finish_screen" was not non-slip safe, so reset the non-slip timer
                              routineTimer.reset();
                              return psychoJS.NEXT;
                            }
                            
                            function rMetaInstructionsRoutineBegin() {
                              //------Prepare to start Routine 'rMetaInstructions'-------
                              t = 0;
                              rMetaInstructionsClock.reset(); // clock
                              frameN = -1;
                              // update component parameters for each repeat
                              respMetaInstructions = new psychoJS.event.BuilderKeyResponse();
                              // keep track of which components have finished
                              rMetaInstructionsComponents = [];
                              rMetaInstructionsComponents.push(tMetaInstructions);
                              rMetaInstructionsComponents.push(respMetaInstructions);
                              for(var i = 0; i < rMetaInstructionsComponents.length; ++i) {
                                thisComponent = rMetaInstructionsComponents[i];
                                if ('status' in thisComponent) {
                                  thisComponent.status = psychoJS.NOT_STARTED;
                                }
                              }
                              
                              return psychoJS.NEXT;
                              }
                              
                              function rMetaInstructionsRoutineEachFrame() {
                                //------Loop for each frame of Routine 'rMetaInstructions'-------
                                continueRoutine = true;
                                 // until we're told otherwise
                                // get current time
                                t = rMetaInstructionsClock.getTime();
                                frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                // update/draw components on each frame
                                
                                // *tMetaInstructions* updates
                                if (t >= 0.0 && tMetaInstructions.status === psychoJS.NOT_STARTED) {
                                  // keep track of start time/frame for later
                                  tMetaInstructions.tStart = t;  // (not accounting for frame time here)
                                  tMetaInstructions.frameNStart = frameN;  // exact frame index
                                  tMetaInstructions.setAutoDraw(true);
                                }
                                
                                // *respMetaInstructions* updates
                                if (t >= 0.0 && respMetaInstructions.status === psychoJS.NOT_STARTED) {
                                  // keep track of start time/frame for later
                                  respMetaInstructions.tStart = t;  // (not accounting for frame time here)
                                  respMetaInstructions.frameNStart = frameN;  // exact frame index
                                  respMetaInstructions.status = psychoJS.STARTED;
                                  // keyboard checking is just starting
                                  respMetaInstructions.clock.reset();  // now t=0
                                  psychoJS.event.clearEvents({eventType:'keyboard'});
                                }
                                if (respMetaInstructions.status == psychoJS.STARTED) {
                                  theseKeys = psychoJS.event.getKeys({keyList:['1', '2']});
                                  
                                  // check for quit:
                                  if ("escape" in theseKeys) {
                                      endExpNow = true;
                                  }
                                  if (theseKeys.length > 0) {  // at least one key was pressed
                                    if (respMetaInstructions.keys.length==0){  // then this was the first keypress
                                      respMetaInstructions.keys = theseKeys[0]  // just the first key pressed
                                      respMetaInstructions.rt = respMetaInstructions.clock.getTime();
                                      // a response ends the routine
                                      continueRoutine = false;
                                    }
                                  }
                                }
                                
                                // check if the Routine should terminate
                                if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                  return psychoJS.NEXT;
                                }
                                continueRoutine = false;// reverts to True if at least one component still running
                                for(var i = 0; i < rMetaInstructionsComponents.length; ++i) {
                                  thisComponent = rMetaInstructionsComponents[i];
                                  if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                    continueRoutine = true;
                                    break;
                                  }
                                }
                                // check for quit (the Esc key)
                                if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                  psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                }
                                
                                // refresh the screen if continuing
                                if (continueRoutine) {
                                  return psychoJS.FLIP_REPEAT;
                                }
                                else {
                                  return psychoJS.NEXT;
                                }
                              }
                              
                              function rMetaInstructionsRoutineEnd() {
                                //------Ending Routine 'rMetaInstructions'-------
                                for (var i = 0; i < rMetaInstructionsComponents.length; ++i) {
                                  thisComponent = rMetaInstructionsComponents[i];
                                  if ("setAutoDraw" in thisComponent) {
                                    thisComponent.setAutoDraw(false);
                                  }
                                }
                                // check responses
                                if (['', [], undefined].indexOf(respMetaInstructions.keys) >= 0) {    // No response was made
                                    respMetaInstructions.keys = undefined;
                                }
                                thisExp.addData('respMetaInstructions.keys',respMetaInstructions.keys);
                                if (respMetaInstructions.keys != undefined) {  // we had a response
                                    thisExp.addData('respMetaInstructions.rt', respMetaInstructions.rt)
                                }
                                // the Routine "rMetaInstructions" was not non-slip safe, so reset the non-slip timer
                                routineTimer.reset();
                                return psychoJS.NEXT;
                              }
                              
                              function trial2RoutineBegin() {
                                //------Prepare to start Routine 'trial2'-------
                                t = 0;
                                trial2Clock.reset(); // clock
                                frameN = -1;
                                // update component parameters for each repeat
                                iOption1Background2.setImage(psychoJS.resourceManager.getResource('images/redbg.png'));
                                delay1_2.setText(SSamount2);
                                delay2_2.setText(LLdelay2);
                                resp_trial2 = new psychoJS.event.BuilderKeyResponse();
                                // keep track of which components have finished
                                trial2Components = [];
                                trial2Components.push(iOption1Background2);
                                trial2Components.push(iOption2Background2);
                                trial2Components.push(delay1_2);
                                trial2Components.push(delay2_2);
                                trial2Components.push(amount1_1);
                                trial2Components.push(amount2_2);
                                trial2Components.push(divider2);
                                trial2Components.push(resp_trial2);
                                trial2Components.push(tRespondTooSlow2);
                                for(var i = 0; i < trial2Components.length; ++i) {
                                  thisComponent = trial2Components[i];
                                  if ('status' in thisComponent) {
                                    thisComponent.status = psychoJS.NOT_STARTED;
                                  }
                                }
                                
                                return psychoJS.NEXT;
                                }
                                
                                function trial2RoutineEachFrame() {
                                  //------Loop for each frame of Routine 'trial2'-------
                                  continueRoutine = true;
                                   // until we're told otherwise
                                  // get current time
                                  t = trial2Clock.getTime();
                                  frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                  // update/draw components on each frame
                                  
                                  // *iOption1Background2* updates
                                  if (t >= 0.0 && iOption1Background2.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    iOption1Background2.tStart = t;  // (not accounting for frame time here)
                                    iOption1Background2.frameNStart = frameN;  // exact frame index
                                    iOption1Background2.setAutoDraw(true);
                                  }
                                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                                  if (iOption1Background2.status === psychoJS.STARTED && t >= frameRemains) {
                                    iOption1Background2.setAutoDraw(false);
                                  }
                                  
                                  // *iOption2Background2* updates
                                  if (t >= 0.0 && iOption2Background2.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    iOption2Background2.tStart = t;  // (not accounting for frame time here)
                                    iOption2Background2.frameNStart = frameN;  // exact frame index
                                    iOption2Background2.setAutoDraw(true);
                                  }
                                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                                  if (iOption2Background2.status === psychoJS.STARTED && t >= frameRemains) {
                                    iOption2Background2.setAutoDraw(false);
                                  }
                                  
                                  // *delay1_2* updates
                                  if (t >= 0.0 && delay1_2.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    delay1_2.tStart = t;  // (not accounting for frame time here)
                                    delay1_2.frameNStart = frameN;  // exact frame index
                                    delay1_2.setAutoDraw(true);
                                  }
                                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                                  if (delay1_2.status === psychoJS.STARTED && t >= frameRemains) {
                                    delay1_2.setAutoDraw(false);
                                  }
                                  
                                  // *delay2_2* updates
                                  if (t >= 0.0 && delay2_2.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    delay2_2.tStart = t;  // (not accounting for frame time here)
                                    delay2_2.frameNStart = frameN;  // exact frame index
                                    delay2_2.setAutoDraw(true);
                                  }
                                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                                  if (delay2_2.status === psychoJS.STARTED && t >= frameRemains) {
                                    delay2_2.setAutoDraw(false);
                                  }
                                  
                                  // *amount1_1* updates
                                  if (t >= 0.0 && amount1_1.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    amount1_1.tStart = t;  // (not accounting for frame time here)
                                    amount1_1.frameNStart = frameN;  // exact frame index
                                    amount1_1.setAutoDraw(true);
                                  }
                                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                                  if (amount1_1.status === psychoJS.STARTED && t >= frameRemains) {
                                    amount1_1.setAutoDraw(false);
                                  }
                                  
                                  // *amount2_2* updates
                                  if (t >= 0.0 && amount2_2.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    amount2_2.tStart = t;  // (not accounting for frame time here)
                                    amount2_2.frameNStart = frameN;  // exact frame index
                                    amount2_2.setAutoDraw(true);
                                  }
                                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                                  if (amount2_2.status === psychoJS.STARTED && t >= frameRemains) {
                                    amount2_2.setAutoDraw(false);
                                  }
                                  
                                  // *divider2* updates
                                  if (t >= 0.0 && divider2.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    divider2.tStart = t;  // (not accounting for frame time here)
                                    divider2.frameNStart = frameN;  // exact frame index
                                    divider2.setAutoDraw(true);
                                  }
                                  frameRemains = 0.0 + 6 - frameDur * 0.75;  // most of one frame period left
                                  if (divider2.status === psychoJS.STARTED && t >= frameRemains) {
                                    divider2.setAutoDraw(false);
                                  }
                                  
                                  // *resp_trial2* updates
                                  if (t >= 0.0 && resp_trial2.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    resp_trial2.tStart = t;  // (not accounting for frame time here)
                                    resp_trial2.frameNStart = frameN;  // exact frame index
                                    resp_trial2.status = psychoJS.STARTED;
                                    // keyboard checking is just starting
                                    resp_trial2.clock.reset();  // now t=0
                                    psychoJS.event.clearEvents({eventType:'keyboard'});
                                  }
                                  if (resp_trial2.status == psychoJS.STARTED) {
                                    theseKeys = psychoJS.event.getKeys({keyList:['1', '2']});
                                    
                                    // check for quit:
                                    if ("escape" in theseKeys) {
                                        endExpNow = true;
                                    }
                                    if (theseKeys.length > 0) {  // at least one key was pressed
                                      if (resp_trial2.keys == []) {  // then this was the first keypress
                                        resp_trial2.keys = theseKeys[0]  // just the first key pressed
                                        resp_trial2.rt = resp_trial2.clock.getTime();
                                        // a response ends the routine
                                        continueRoutine = false;
                                      }
                                    }
                                  }
                                  
                                  // *tRespondTooSlow2* updates
                                  if (t >= 0.0 && tRespondTooSlow2.status === psychoJS.NOT_STARTED) {
                                    // keep track of start time/frame for later
                                    tRespondTooSlow2.tStart = t;  // (not accounting for frame time here)
                                    tRespondTooSlow2.frameNStart = frameN;  // exact frame index
                                    tRespondTooSlow2.setAutoDraw(true);
                                  }
                                  
                                  // check if the Routine should terminate
                                  if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                    return psychoJS.NEXT;
                                  }
                                  continueRoutine = false;// reverts to True if at least one component still running
                                  for(var i = 0; i < trial2Components.length; ++i) {
                                    thisComponent = trial2Components[i];
                                    if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                      continueRoutine = true;
                                      break;
                                    }
                                  }
                                  // check for quit (the Esc key)
                                  if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                    psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                  }
                                  
                                  // refresh the screen if continuing
                                  if (continueRoutine) {
                                    return psychoJS.FLIP_REPEAT;
                                  }
                                  else {
                                    return psychoJS.NEXT;
                                  }
                                }
                                
                                function trial2RoutineEnd() {
                                  //------Ending Routine 'trial2'-------
                                  for (var i = 0; i < trial2Components.length; ++i) {
                                    thisComponent = trial2Components[i];
                                    if ("setAutoDraw" in thisComponent) {
                                      thisComponent.setAutoDraw(false);
                                    }
                                  }
                                  // check responses
                                  if (['', [], undefined].indexOf(resp_trial2.keys) >= 0) {    // No response was made
                                      resp_trial2.keys = undefined;
                                  }
                                  thisExp.addData('resp_trial2.keys',resp_trial2.keys);
                                  if (resp_trial2.keys != undefined) {  // we had a response
                                      thisExp.addData('resp_trial2.rt', resp_trial2.rt)
                                  }
                                  // the Routine "trial2" was not non-slip safe, so reset the non-slip timer
                                  routineTimer.reset();
                                  return psychoJS.NEXT;
                                }
                                
                                function construal_trial_b2_1RoutineBegin() {
                                  //------Prepare to start Routine 'construal_trial_b2_1'-------
                                  t = 0;
                                  construal_trial_b2_1Clock.reset(); // clock
                                  frameN = -1;
                                  // update component parameters for each repeat
                                  // keep track of which components have finished
                                  construal_trial_b2_1Components = [];
                                  for(var i = 0; i < construal_trial_b2_1Components.length; ++i) {
                                    thisComponent = construal_trial_b2_1Components[i];
                                    if ('status' in thisComponent) {
                                      thisComponent.status = psychoJS.NOT_STARTED;
                                    }
                                  }
                                  
                                  return psychoJS.NEXT;
                                  }
                                  
                                  function construal_trial_b2_1RoutineEachFrame() {
                                    //------Loop for each frame of Routine 'construal_trial_b2_1'-------
                                    continueRoutine = true;
                                     // until we're told otherwise
                                    // get current time
                                    t = construal_trial_b2_1Clock.getTime();
                                    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                    // update/draw components on each frame
                                    
                                    // check if the Routine should terminate
                                    if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                      return psychoJS.NEXT;
                                    }
                                    continueRoutine = false;// reverts to True if at least one component still running
                                    for(var i = 0; i < construal_trial_b2_1Components.length; ++i) {
                                      thisComponent = construal_trial_b2_1Components[i];
                                      if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                        continueRoutine = true;
                                        break;
                                      }
                                    }
                                    // check for quit (the Esc key)
                                    if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                      psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                    }
                                    
                                    // refresh the screen if continuing
                                    if (continueRoutine) {
                                      return psychoJS.FLIP_REPEAT;
                                    }
                                    else {
                                      return psychoJS.NEXT;
                                    }
                                  }
                                  
                                  function construal_trial_b2_1RoutineEnd() {
                                    //------Ending Routine 'construal_trial_b2_1'-------
                                    for (var i = 0; i < construal_trial_b2_1Components.length; ++i) {
                                      thisComponent = construal_trial_b2_1Components[i];
                                      if ("setAutoDraw" in thisComponent) {
                                        thisComponent.setAutoDraw(false);
                                      }
                                    }
                                    // the Routine "construal_trial_b2_1" was not non-slip safe, so reset the non-slip timer
                                    routineTimer.reset();
                                    return psychoJS.NEXT;
                                  }
                                  
                                  function rBlock2InstructionsRoutineBegin() {
                                    //------Prepare to start Routine 'rBlock2Instructions'-------
                                    t = 0;
                                    rBlock2InstructionsClock.reset(); // clock
                                    frameN = -1;
                                    // update component parameters for each repeat
                                    // keep track of which components have finished
                                    rBlock2InstructionsComponents = [];
                                    for(var i = 0; i < rBlock2InstructionsComponents.length; ++i) {
                                      thisComponent = rBlock2InstructionsComponents[i];
                                      if ('status' in thisComponent) {
                                        thisComponent.status = psychoJS.NOT_STARTED;
                                      }
                                    }
                                    
                                    return psychoJS.NEXT;
                                    }
                                    
                                    function rBlock2InstructionsRoutineEachFrame() {
                                      //------Loop for each frame of Routine 'rBlock2Instructions'-------
                                      continueRoutine = true;
                                       // until we're told otherwise
                                      // get current time
                                      t = rBlock2InstructionsClock.getTime();
                                      frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                      // update/draw components on each frame
                                      
                                      // check if the Routine should terminate
                                      if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                        return psychoJS.NEXT;
                                      }
                                      continueRoutine = false;// reverts to True if at least one component still running
                                      for(var i = 0; i < rBlock2InstructionsComponents.length; ++i) {
                                        thisComponent = rBlock2InstructionsComponents[i];
                                        if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                          continueRoutine = true;
                                          break;
                                        }
                                      }
                                      // check for quit (the Esc key)
                                      if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                        psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                      }
                                      
                                      // refresh the screen if continuing
                                      if (continueRoutine) {
                                        return psychoJS.FLIP_REPEAT;
                                      }
                                      else {
                                        return psychoJS.NEXT;
                                      }
                                    }
                                    
                                    function rBlock2InstructionsRoutineEnd() {
                                      //------Ending Routine 'rBlock2Instructions'-------
                                      for (var i = 0; i < rBlock2InstructionsComponents.length; ++i) {
                                        thisComponent = rBlock2InstructionsComponents[i];
                                        if ("setAutoDraw" in thisComponent) {
                                          thisComponent.setAutoDraw(false);
                                        }
                                      }
                                      // the Routine "rBlock2Instructions" was not non-slip safe, so reset the non-slip timer
                                      routineTimer.reset();
                                      return psychoJS.NEXT;
                                    }
                                    
                                                          function construal_trialRoutineBegin() {
                        //------Prepare to start Routine 'construal_trial'-------
                        on_construal_trialRoutineBegin();
                                      t = 0;
                                      construal_trialClock.reset(); // clock
                                      frameN = -1;
                                      // update component parameters for each repeat
                                      tConstrualQuestion.setText(Construal_QuestionText);
                                      tConstrualAnswer.setText(Construal_AnswerText);
                                      construal_resp = new psychoJS.event.BuilderKeyResponse();
                                      // keep track of which components have finished
                                      construal_trialComponents = [];
                                      construal_trialComponents.push(tConstrualQuestion);
                                      construal_trialComponents.push(tConstrualAnswer);
                                      construal_trialComponents.push(construal_resp);
                                      construal_trialComponents.push(yes1);
                                      construal_trialComponents.push(no2);
                                      for(var i = 0; i < construal_trialComponents.length; ++i) {
                                        thisComponent = construal_trialComponents[i];
                                        if ('status' in thisComponent) {
                                          thisComponent.status = psychoJS.NOT_STARTED;
                                        }
                                      }
                                      
                                      return psychoJS.NEXT;
                                      }
                                      
                                      function construal_trialRoutineEachFrame() {
                                        //------Loop for each frame of Routine 'construal_trial'-------
                                        continueRoutine = true;
                                         // until we're told otherwise
                                        // get current time
                                        t = construal_trialClock.getTime();
                                        frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                        // update/draw components on each frame
                                        
                                        // *tConstrualQuestion* updates
                                        if (t >= 0.0 && tConstrualQuestion.status === psychoJS.NOT_STARTED) {
                                          // keep track of start time/frame for later
                                          tConstrualQuestion.tStart = t;  // (not accounting for frame time here)
                                          tConstrualQuestion.frameNStart = frameN;  // exact frame index
                                          tConstrualQuestion.setAutoDraw(true);
                                        }
                                        frameRemains = 0.0 + 1.5 - frameDur * 0.75;  // most of one frame period left
                                        if (tConstrualQuestion.status === psychoJS.STARTED && t >= frameRemains) {
                                          tConstrualQuestion.setAutoDraw(false);
                                        }
                                        
                                        // *tConstrualAnswer* updates
                                        if (t >= 1.75 && tConstrualAnswer.status === psychoJS.NOT_STARTED) {
                                          // keep track of start time/frame for later
                                          tConstrualAnswer.tStart = t;  // (not accounting for frame time here)
                                          tConstrualAnswer.frameNStart = frameN;  // exact frame index
                                          tConstrualAnswer.setAutoDraw(true);
                                        }
                                        frameRemains = 1.75 + 2.25 - frameDur * 0.75;  // most of one frame period left
                                        if (tConstrualAnswer.status === psychoJS.STARTED && t >= frameRemains) {
                                          tConstrualAnswer.setAutoDraw(false);
                                        }
                                        
                                        // *construal_resp* updates
                                        if (t >= 1.75 && construal_resp.status === psychoJS.NOT_STARTED) {
                                          // keep track of start time/frame for later
                                          construal_resp.tStart = t;  // (not accounting for frame time here)
                                          construal_resp.frameNStart = frameN;  // exact frame index
                                          construal_resp.status = psychoJS.STARTED;
                                          // keyboard checking is just starting
                                          construal_resp.clock.reset();  // now t=0
                                          psychoJS.event.clearEvents({eventType:'keyboard'});
                                        }
                                        if (construal_resp.status == psychoJS.STARTED) {
                                          theseKeys = psychoJS.event.getKeys({keyList:['1', '2']});
                                          
                                          // check for quit:
                                          if ("escape" in theseKeys) {
                                              endExpNow = true;
                                          }
                                          if (theseKeys.length > 0) {  // at least one key was pressed
                                                                        if (construal_resp.keys.length==0) {  // then this was the first keypress
                                              construal_resp.keys = theseKeys[0]  // just the first key pressed
                                              construal_resp.rt = construal_resp.clock.getTime();
                                              // a response ends the routine
                                              continueRoutine = false;
                                            }
                                          }
                                        }
                                        
                                        // *yes1* updates
                                        if (t >= 1.75 && yes1.status === psychoJS.NOT_STARTED) {
                                          // keep track of start time/frame for later
                                          yes1.tStart = t;  // (not accounting for frame time here)
                                          yes1.frameNStart = frameN;  // exact frame index
                                          yes1.setAutoDraw(true);
                                        }
                                        frameRemains = 1.75 + 2.25 - frameDur * 0.75;  // most of one frame period left
                                        if (yes1.status === psychoJS.STARTED && t >= frameRemains) {
                                          yes1.setAutoDraw(false);
                                        }
                                        
                                        // *no2* updates
                                        if (t >= 1.75 && no2.status === psychoJS.NOT_STARTED) {
                                          // keep track of start time/frame for later
                                          no2.tStart = t;  // (not accounting for frame time here)
                                          no2.frameNStart = frameN;  // exact frame index
                                          no2.setAutoDraw(true);
                                        }
                                        frameRemains = 1.75 + 2.25 - frameDur * 0.75;  // most of one frame period left
                                        if (no2.status === psychoJS.STARTED && t >= frameRemains) {
                                          no2.setAutoDraw(false);
                                        }
                                        
                                        // check if the Routine should terminate
                                        if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                          return psychoJS.NEXT;
                                        }
                                        continueRoutine = false;// reverts to True if at least one component still running
                                        for(var i = 0; i < construal_trialComponents.length; ++i) {
                                          thisComponent = construal_trialComponents[i];
                                          if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                            continueRoutine = true;
                                            break;
                                          }
                                        }
                                        // check for quit (the Esc key)
                                        if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                          psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                        }
                                        
                                        						after_construal_trialRoutineEachFrame();
                          // refresh the screen if continuing
                          if (continueRoutine) {
                            return psychoJS.FLIP_REPEAT;
                          }
                          else {
                            return psychoJS.NEXT;
                          }
                        }
                        
                                                function construal_trialRoutineEnd() {
                          //------Ending Routine 'construal_trial'-------
                          on_construal_trialRoutineEnd();
                                        for (var i = 0; i < construal_trialComponents.length; ++i) {
                                          thisComponent = construal_trialComponents[i];
                                          if ("setAutoDraw" in thisComponent) {
                                            thisComponent.setAutoDraw(false);
                                          }
                                        }
                                        // check responses
                                        if (['', [], undefined].indexOf(construal_resp.keys) >= 0) {    // No response was made
                                            construal_resp.keys = undefined;
                                        }
                                        thisExp.addData('construal_resp.keys',construal_resp.keys);
                                        if (construal_resp.keys != undefined) {  // we had a response
                                            thisExp.addData('construal_resp.rt', construal_resp.rt)
                                        }
                                        // the Routine "construal_trial" was not non-slip safe, so reset the non-slip timer
                                        routineTimer.reset();
                                        return psychoJS.NEXT;
                                      }
                                      
                                      function rHowWhyTaskInstructionsRoutineBegin() {
                                        //------Prepare to start Routine 'rHowWhyTaskInstructions'-------
                                        t = 0;
                                        rHowWhyTaskInstructionsClock.reset(); // clock
                                        frameN = -1;
                                        // update component parameters for each repeat
                                        iHowWhyTaskInstructions.setImage(psychoJS.resourceManager.getResource('images/construal-stimuli/howwhytest_instructions.jpg'));
                                        respHowWhyTaskInstructions = new psychoJS.event.BuilderKeyResponse();
                                        // keep track of which components have finished
                                        rHowWhyTaskInstructionsComponents = [];
                                        rHowWhyTaskInstructionsComponents.push(iHowWhyTaskInstructions);
                                        rHowWhyTaskInstructionsComponents.push(respHowWhyTaskInstructions);
                                        for(var i = 0; i < rHowWhyTaskInstructionsComponents.length; ++i) {
                                          thisComponent = rHowWhyTaskInstructionsComponents[i];
                                          if ('status' in thisComponent) {
                                            thisComponent.status = psychoJS.NOT_STARTED;
                                          }
                                        }
                                        
                                        return psychoJS.NEXT;
                                        }
                                        
                                        function rHowWhyTaskInstructionsRoutineEachFrame() {
                                          //------Loop for each frame of Routine 'rHowWhyTaskInstructions'-------
                                          continueRoutine = true;
                                           // until we're told otherwise
                                          // get current time
                                          t = rHowWhyTaskInstructionsClock.getTime();
                                          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                          // update/draw components on each frame
                                          
                                          // *iHowWhyTaskInstructions* updates
                                          if (t >= 0.0 && iHowWhyTaskInstructions.status === psychoJS.NOT_STARTED) {
                                            // keep track of start time/frame for later
                                            iHowWhyTaskInstructions.tStart = t;  // (not accounting for frame time here)
                                            iHowWhyTaskInstructions.frameNStart = frameN;  // exact frame index
                                            iHowWhyTaskInstructions.setAutoDraw(true);
                                          }
                                          
                                          // *respHowWhyTaskInstructions* updates
                                          if (t >= 0.0 && respHowWhyTaskInstructions.status === psychoJS.NOT_STARTED) {
                                            // keep track of start time/frame for later
                                            respHowWhyTaskInstructions.tStart = t;  // (not accounting for frame time here)
                                            respHowWhyTaskInstructions.frameNStart = frameN;  // exact frame index
                                            respHowWhyTaskInstructions.status = psychoJS.STARTED;
                                            // keyboard checking is just starting
                                            respHowWhyTaskInstructions.clock.reset();  // now t=0
                                            psychoJS.event.clearEvents({eventType:'keyboard'});
                                          }
                                          if (respHowWhyTaskInstructions.status == psychoJS.STARTED) {
                                            theseKeys = psychoJS.event.getKeys({keyList:['1', '2']});
                                            
                                            // check for quit:
                                            if ("escape" in theseKeys) {
                                                endExpNow = true;
                                            }
                                            if (theseKeys.length > 0) {  // at least one key was pressed
                                              respHowWhyTaskInstructions.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
                                              respHowWhyTaskInstructions.rt = respHowWhyTaskInstructions.clock.getTime();
                                              // a response ends the routine
                                              continueRoutine = false;
                                            }
                                          }
                                          
                                          // check if the Routine should terminate
                                          if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                            return psychoJS.NEXT;
                                          }
                                          continueRoutine = false;// reverts to True if at least one component still running
                                          for(var i = 0; i < rHowWhyTaskInstructionsComponents.length; ++i) {
                                            thisComponent = rHowWhyTaskInstructionsComponents[i];
                                            if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                              continueRoutine = true;
                                              break;
                                            }
                                          }
                                          // check for quit (the Esc key)
                                          if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                            psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                          }
                                          
                                          // refresh the screen if continuing
                                          if (continueRoutine) {
                                            return psychoJS.FLIP_REPEAT;
                                          }
                                          else {
                                            return psychoJS.NEXT;
                                          }
                                        }
                                        
                                        function rHowWhyTaskInstructionsRoutineEnd() {
                                          //------Ending Routine 'rHowWhyTaskInstructions'-------
                                          for (var i = 0; i < rHowWhyTaskInstructionsComponents.length; ++i) {
                                            thisComponent = rHowWhyTaskInstructionsComponents[i];
                                            if ("setAutoDraw" in thisComponent) {
                                              thisComponent.setAutoDraw(false);
                                            }
                                          }
                                          // check responses
                                          if (['', [], undefined].indexOf(respHowWhyTaskInstructions.keys) >= 0) {    // No response was made
                                              respHowWhyTaskInstructions.keys = undefined;
                                          }
                                          thisExp.addData('respHowWhyTaskInstructions.keys',respHowWhyTaskInstructions.keys);
                                          if (respHowWhyTaskInstructions.keys != undefined) {  // we had a response
                                              thisExp.addData('respHowWhyTaskInstructions.rt', respHowWhyTaskInstructions.rt)
                                          }
                                          // the Routine "rHowWhyTaskInstructions" was not non-slip safe, so reset the non-slip timer
                                          routineTimer.reset();
                                          return psychoJS.NEXT;
                                        }
                                        
                                        function beginRoutineRoutineBegin() {
                                          //------Prepare to start Routine 'beginRoutine'-------
                                          t = 0;
                                          beginRoutineClock.reset(); // clock
                                          frameN = -1;
                                          routineTimer.add(0.500000);
                                          // update component parameters for each repeat
                                          // keep track of which components have finished
                                          beginRoutineComponents = [];
                                          beginRoutineComponents.push(tLoading);
                                          for(var i = 0; i < beginRoutineComponents.length; ++i) {
                                            thisComponent = beginRoutineComponents[i];
                                            if ('status' in thisComponent) {
                                              thisComponent.status = psychoJS.NOT_STARTED;
                                            }
                                          }
                                          
                                          return psychoJS.NEXT;
                                          }
                                          
                                          function beginRoutineRoutineEachFrame() {
                                            //------Loop for each frame of Routine 'beginRoutine'-------
                                            continueRoutine = true;
                                             // until we're told otherwise
                                            // get current time
                                            t = beginRoutineClock.getTime();
                                            frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                            // update/draw components on each frame
                                            
                                            // *tLoading* updates
                                            if (t >= 0.0 && tLoading.status === psychoJS.NOT_STARTED) {
                                              // keep track of start time/frame for later
                                              tLoading.tStart = t;  // (not accounting for frame time here)
                                              tLoading.frameNStart = frameN;  // exact frame index
                                              tLoading.setAutoDraw(true);
                                            }
                                            frameRemains = 0.0 + 0.5 - frameDur * 0.75;  // most of one frame period left
                                            if (tLoading.status === psychoJS.STARTED && t >= frameRemains) {
                                              tLoading.setAutoDraw(false);
                                            }
                                            
                                            // check if the Routine should terminate
                                            if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                              return psychoJS.NEXT;
                                            }
                                            continueRoutine = false;// reverts to True if at least one component still running
                                            for(var i = 0; i < beginRoutineComponents.length; ++i) {
                                              thisComponent = beginRoutineComponents[i];
                                              if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                                continueRoutine = true;
                                                break;
                                              }
                                            }
                                            // check for quit (the Esc key)
                                            if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                              psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                            }
                                            
                                            // refresh the screen if continuing
                                            if (continueRoutine && routineTimer.getTime() > 0) {
                                              return psychoJS.FLIP_REPEAT;
                                            }
                                            else {
                                              return psychoJS.NEXT;
                                            }
                                          }
                                          
                                          function beginRoutineRoutineEnd() {
                                            //------Ending Routine 'beginRoutine'-------
                                            for (var i = 0; i < beginRoutineComponents.length; ++i) {
                                              thisComponent = beginRoutineComponents[i];
                                              if ("setAutoDraw" in thisComponent) {
                                                thisComponent.setAutoDraw(false);
                                              }
                                            }
                                            return psychoJS.NEXT;
                                          }
                                          
                                          function construal_trial2RoutineBegin() {
                                            //------Prepare to start Routine 'construal_trial2'-------
                                            t = 0;
                                            construal_trial2Clock.reset(); // clock
                                            frameN = -1;
                                            // update component parameters for each repeat
                                            tConstrualQuestion2.setText(Construal_QuestionText2);
                                            tConstrualAnswer2.setText(Construal_AnswerText2);
                                            construal_resp2 = new psychoJS.event.BuilderKeyResponse();
                                            // keep track of which components have finished
                                            construal_trial2Components = [];
                                            construal_trial2Components.push(tConstrualQuestion2);
                                            construal_trial2Components.push(tConstrualAnswer2);
                                            construal_trial2Components.push(construal_resp2);
                                            construal_trial2Components.push(yes1_2);
                                            construal_trial2Components.push(no2_2);
                                            for(var i = 0; i < construal_trial2Components.length; ++i) {
                                              thisComponent = construal_trial2Components[i];
                                              if ('status' in thisComponent) {
                                                thisComponent.status = psychoJS.NOT_STARTED;
                                              }
                                            }
                                            
                                            return psychoJS.NEXT;
                                            }
                                            
                                            function construal_trial2RoutineEachFrame() {
                                              //------Loop for each frame of Routine 'construal_trial2'-------
                                              continueRoutine = true;
                                               // until we're told otherwise
                                              // get current time
                                              t = construal_trial2Clock.getTime();
                                              frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                              // update/draw components on each frame
                                              
                                              // *tConstrualQuestion2* updates
                                              if (t >= 0.0 && tConstrualQuestion2.status === psychoJS.NOT_STARTED) {
                                                // keep track of start time/frame for later
                                                tConstrualQuestion2.tStart = t;  // (not accounting for frame time here)
                                                tConstrualQuestion2.frameNStart = frameN;  // exact frame index
                                                tConstrualQuestion2.setAutoDraw(true);
                                              }
                                              frameRemains = 0.0 + 1.5 - frameDur * 0.75;  // most of one frame period left
                                              if (tConstrualQuestion2.status === psychoJS.STARTED && t >= frameRemains) {
                                                tConstrualQuestion2.setAutoDraw(false);
                                              }
                                              
                                              // *tConstrualAnswer2* updates
                                              if (t >= 1.75 && tConstrualAnswer2.status === psychoJS.NOT_STARTED) {
                                                // keep track of start time/frame for later
                                                tConstrualAnswer2.tStart = t;  // (not accounting for frame time here)
                                                tConstrualAnswer2.frameNStart = frameN;  // exact frame index
                                                tConstrualAnswer2.setAutoDraw(true);
                                              }
                                              frameRemains = 1.75 + 2.25 - frameDur * 0.75;  // most of one frame period left
                                              if (tConstrualAnswer2.status === psychoJS.STARTED && t >= frameRemains) {
                                                tConstrualAnswer2.setAutoDraw(false);
                                              }
                                              
                                              // *construal_resp2* updates
                                              if (t >= 1.75 && construal_resp2.status === psychoJS.NOT_STARTED) {
                                                // keep track of start time/frame for later
                                                construal_resp2.tStart = t;  // (not accounting for frame time here)
                                                construal_resp2.frameNStart = frameN;  // exact frame index
                                                construal_resp2.status = psychoJS.STARTED;
                                                // keyboard checking is just starting
                                                construal_resp2.clock.reset();  // now t=0
                                                psychoJS.event.clearEvents({eventType:'keyboard'});
                                              }
                                              if (construal_resp2.status == psychoJS.STARTED) {
                                                theseKeys = psychoJS.event.getKeys({keyList:['1', '2']});
                                                
                                                // check for quit:
                                                if ("escape" in theseKeys) {
                                                    endExpNow = true;
                                                }
                                                if (theseKeys.length > 0) {  // at least one key was pressed
                                                  if (construal_resp2.keys == []) {  // then this was the first keypress
                                                    construal_resp2.keys = theseKeys[0]  // just the first key pressed
                                                    construal_resp2.rt = construal_resp2.clock.getTime();
                                                    // a response ends the routine
                                                    continueRoutine = false;
                                                  }
                                                }
                                              }
                                              
                                              // *yes1_2* updates
                                              if (t >= 1.75 && yes1_2.status === psychoJS.NOT_STARTED) {
                                                // keep track of start time/frame for later
                                                yes1_2.tStart = t;  // (not accounting for frame time here)
                                                yes1_2.frameNStart = frameN;  // exact frame index
                                                yes1_2.setAutoDraw(true);
                                              }
                                              frameRemains = 1.75 + 2.25 - frameDur * 0.75;  // most of one frame period left
                                              if (yes1_2.status === psychoJS.STARTED && t >= frameRemains) {
                                                yes1_2.setAutoDraw(false);
                                              }
                                              
                                              // *no2_2* updates
                                              if (t >= 1.75 && no2_2.status === psychoJS.NOT_STARTED) {
                                                // keep track of start time/frame for later
                                                no2_2.tStart = t;  // (not accounting for frame time here)
                                                no2_2.frameNStart = frameN;  // exact frame index
                                                no2_2.setAutoDraw(true);
                                              }
                                              frameRemains = 1.75 + 2.25 - frameDur * 0.75;  // most of one frame period left
                                              if (no2_2.status === psychoJS.STARTED && t >= frameRemains) {
                                                no2_2.setAutoDraw(false);
                                              }
                                              
                                              // check if the Routine should terminate
                                              if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                                return psychoJS.NEXT;
                                              }
                                              continueRoutine = false;// reverts to True if at least one component still running
                                              for(var i = 0; i < construal_trial2Components.length; ++i) {
                                                thisComponent = construal_trial2Components[i];
                                                if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                                  continueRoutine = true;
                                                  break;
                                                }
                                              }
                                              // check for quit (the Esc key)
                                              if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                                psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                              }
                                              
                                              // refresh the screen if continuing
                                              if (continueRoutine) {
                                                return psychoJS.FLIP_REPEAT;
                                              }
                                              else {
                                                return psychoJS.NEXT;
                                              }
                                            }
                                            
                                            function construal_trial2RoutineEnd() {
                                              //------Ending Routine 'construal_trial2'-------
                                              for (var i = 0; i < construal_trial2Components.length; ++i) {
                                                thisComponent = construal_trial2Components[i];
                                                if ("setAutoDraw" in thisComponent) {
                                                  thisComponent.setAutoDraw(false);
                                                }
                                              }
                                              // check responses
                                              if (['', [], undefined].indexOf(construal_resp2.keys) >= 0) {    // No response was made
                                                  construal_resp2.keys = undefined;
                                              }
                                              thisExp.addData('construal_resp2.keys',construal_resp2.keys);
                                              if (construal_resp2.keys != undefined) {  // we had a response
                                                  thisExp.addData('construal_resp2.rt', construal_resp2.rt)
                                              }
                                              // the Routine "construal_trial2" was not non-slip safe, so reset the non-slip timer
                                              routineTimer.reset();
                                              return psychoJS.NEXT;
                                            }
                                            
                                            function ITIfix_b2_1RoutineBegin() {
                                              //------Prepare to start Routine 'ITIfix_b2_1'-------
                                              t = 0;
                                              ITIfix_b2_1Clock.reset(); // clock
                                              frameN = -1;
                                              // update component parameters for each repeat
                                              // keep track of which components have finished
                                              ITIfix_b2_1Components = [];
                                              for(var i = 0; i < ITIfix_b2_1Components.length; ++i) {
                                                thisComponent = ITIfix_b2_1Components[i];
                                                if ('status' in thisComponent) {
                                                  thisComponent.status = psychoJS.NOT_STARTED;
                                                }
                                              }
                                              
                                              return psychoJS.NEXT;
                                              }
                                              
                                              function ITIfix_b2_1RoutineEachFrame() {
                                                //------Loop for each frame of Routine 'ITIfix_b2_1'-------
                                                continueRoutine = true;
                                                 // until we're told otherwise
                                                // get current time
                                                t = ITIfix_b2_1Clock.getTime();
                                                frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                                                // update/draw components on each frame
                                                
                                                // check if the Routine should terminate
                                                if (!continueRoutine) {  // a component has requested a forced-end of Routine
                                                  return psychoJS.NEXT;
                                                }
                                                continueRoutine = false;// reverts to True if at least one component still running
                                                for(var i = 0; i < ITIfix_b2_1Components.length; ++i) {
                                                  thisComponent = ITIfix_b2_1Components[i];
                                                  if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                                                    continueRoutine = true;
                                                    break;
                                                  }
                                                }
                                                // check for quit (the Esc key)
                                                if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                                                  psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                                                }
                                                
                                                // refresh the screen if continuing
                                                if (continueRoutine) {
                                                  return psychoJS.FLIP_REPEAT;
                                                }
                                                else {
                                                  return psychoJS.NEXT;
                                                }
                                              }
                                              
                                              function ITIfix_b2_1RoutineEnd() {
                                                //------Ending Routine 'ITIfix_b2_1'-------
                                                for (var i = 0; i < ITIfix_b2_1Components.length; ++i) {
                                                  thisComponent = ITIfix_b2_1Components[i];
                                                  if ("setAutoDraw" in thisComponent) {
                                                    thisComponent.setAutoDraw(false);
                                                  }
                                                }
                                                // the Routine "ITIfix_b2_1" was not non-slip safe, so reset the non-slip timer
                                                routineTimer.reset();
                                                return psychoJS.NEXT;
                                              }
                                              
                                              function registerResources() {
                                                  psychoJS.resourceManager.scheduleRegistration(resourceScheduler);
                                              
                                                  return psychoJS.NEXT;
                                              }
                                              
                                              function downloadResources() {
                                                  psychoJS.resourceManager.scheduleDownload(resourceScheduler);
                                              
                                                  return psychoJS.NEXT;
                                              }
                                              
                                              function instructionLoopLoopBegin(thisScheduler) {
                                                // set up handler to look after randomisation of conditions etc
                                                try {
                                                  instructionLoop = new psychoJS.data.TrialHandler({nReps:expInfo['run'].toLowerCase().startsWith('p'), method:'sequential',
                                                    extraInfo:expInfo, originPath:undefined,
                                                    trialList:psychoJS.data.importConditions('blockcontrol.csv'),
                                                    seed:undefined, name:'instructionLoop'});
                                                  thisExp.addLoop(instructionLoop); // add the loop to the experiment
                                                  thisInstructionLoop = instructionLoop.trialList[instructionLoop.trialSequence[0]]; // so we can initialise stimuli with some values
                                                  // abbreviate parameter names if possible (e.g. rgb=thisInstructionLoop.rgb)
                                                  abbrevNames(thisInstructionLoop);
                                                  // Schedule each of the trials in the list to occur
                                                  for (var i = 0; i < instructionLoop.trialSequence.length; ++i) {
                                                    thisInstructionLoop = instructionLoop.trialList[instructionLoop.trialSequence[i]];
                                                    thisScheduler.add(abbrevNames(thisInstructionLoop));
                                                    thisScheduler.add(rTaskInstructionsRoutineBegin);
                                                    thisScheduler.add(rTaskInstructionsRoutineEachFrame);
                                                    thisScheduler.add(rTaskInstructionsRoutineEnd);
                                                    thisScheduler.add(rHowWhyTaskInstructionsRoutineBegin);
                                                    thisScheduler.add(rHowWhyTaskInstructionsRoutineEachFrame);
                                                    thisScheduler.add(rHowWhyTaskInstructionsRoutineEnd);
                                                  }
                                                } catch (exception) {
                                                  console.log(exception);
                                                }
                                              
                                                return psychoJS.NEXT;
                                              }
                                              
                                              function instructionLoopLoopEnd() {
                                                // get names of stimulus parameters
                                                if (psychoJS.isEmpty(instructionLoop.trialList)) { // XXX equiv of : in ([], [None], None)
                                                  params = [];
                                                }
                                                else {
                                                  params = Object.keys(instructionLoop.trialList[0]);
                                                }
                                              
                                                // save data for this loop
                                                thisExp.loopEnded(instructionLoop);
                                                return psychoJS.NEXT;
                                                }
                                              
                                              function blocksLoopBegin(thisScheduler) {
                                                // set up handler to look after randomisation of conditions etc
                                                try {
                                                  blocks = new psychoJS.data.TrialHandler({nReps:1, method:'sequential',
                                                    extraInfo:expInfo, originPath:undefined,
                                                    trialList:psychoJS.data.importConditions(('design_csv_files/'+expInfo['designDir']+'/metaloop_sub[participant]d[session]r[run].csv'.replace("[participant]",expInfo['participant']).replace("[session]",expInfo['session']).replace("[run]",expInfo['run']))),
                                                    seed:undefined, name:'blocks'});
                                                  thisExp.addLoop(blocks); // add the loop to the experiment
                                                  thisBlock = blocks.trialList[blocks.trialSequence[0]]; // so we can initialise stimuli with some values
                                                  // abbreviate parameter names if possible (e.g. rgb=thisBlock.rgb)
                                                  abbrevNames(thisBlock);
                                                  // Schedule each of the trials in the list to occur
                                                  for (var i = 0; i < blocks.trialSequence.length; ++i) {
                                                    thisBlock = blocks.trialList[blocks.trialSequence[i]];
                                                    thisScheduler.add(abbrevNames(thisBlock));
                                                    thisScheduler.add(rBlockInstructionsRoutineBegin);
                                                    thisScheduler.add(rBlockInstructionsRoutineEachFrame);
                                                    thisScheduler.add(rBlockInstructionsRoutineEnd);
                                                    trials_set1LoopScheduler = new psychoJS.Scheduler();
                                                    thisScheduler.add(trials_set1LoopBegin, trials_set1LoopScheduler);
                                                    thisScheduler.add(trials_set1LoopScheduler);
                                                    thisScheduler.add(trials_set1LoopEnd);
                                                  }
                                                } catch (exception) {
                                                  console.log(exception);
                                                }
                                              
                                                return psychoJS.NEXT;
                                              }
                                              
                                              function trials_set1LoopBegin(thisScheduler) {
                                                // set up handler to look after randomisation of conditions etc
                                                try {
                                                  trials_set1 = new psychoJS.data.TrialHandler({nReps:1, method:'sequential',
                                                    extraInfo:expInfo, originPath:undefined,
                                                    trialList:psychoJS.data.importConditions((LoopFile.replace("[participant]",expInfo['participant']).replace("[session]",expInfo['session']))),
                                                    seed:undefined, name:'trials_set1'});
                                                  thisExp.addLoop(trials_set1); // add the loop to the experiment
                                                  thisTrials_set1 = trials_set1.trialList[trials_set1.trialSequence[0]]; // so we can initialise stimuli with some values
                                                  // abbreviate parameter names if possible (e.g. rgb=thisTrials_set1.rgb)
                                                  abbrevNames(thisTrials_set1);
                                                  // Schedule each of the trials in the list to occur
                                                  for (var i = 0; i < trials_set1.trialSequence.length; ++i) {
                                                    thisTrials_set1 = trials_set1.trialList[trials_set1.trialSequence[i]];
                                                    thisScheduler.add(abbrevNames(thisTrials_set1));
                                                    thisScheduler.add(ITIfixRoutineBegin);
                                                    thisScheduler.add(ITIfixRoutineEachFrame);
                                                    thisScheduler.add(ITIfixRoutineEnd);
                                                    thisScheduler.add(construal_trialRoutineBegin);
                                                    thisScheduler.add(construal_trialRoutineEachFrame);
                                                    thisScheduler.add(construal_trialRoutineEnd);
                                                    thisScheduler.add(rTaskIntervalRoutineBegin);
                                                    thisScheduler.add(rTaskIntervalRoutineEachFrame);
                                                    thisScheduler.add(rTaskIntervalRoutineEnd);
                                                    thisScheduler.add(trialRoutineBegin);
                                                    thisScheduler.add(trialRoutineEachFrame);
                                                    thisScheduler.add(trialRoutineEnd);
                                                    thisScheduler.add(recordLoopIteration(trials_set1));
                                                  }
                                                } catch (exception) {
                                                  console.log(exception);
                                                }
                                              
                                                return psychoJS.NEXT;
                                              }
                                              
                                              function trials_set1LoopEnd() {
                                                // get names of stimulus parameters
                                                if (psychoJS.isEmpty(trials_set1.trialList)) { // XXX equiv of : in ([], [None], None)
                                                  params = [];
                                                }
                                                else {
                                                  params = Object.keys(trials_set1.trialList[0]);
                                                }
                                              
                                                // save data for this loop
                                                thisExp.loopEnded(trials_set1);
                                                return psychoJS.NEXT;
                                                }
                                              
                                              function blocksLoopEnd() {
                                                // get names of stimulus parameters
                                                if (psychoJS.isEmpty(blocks.trialList)) { // XXX equiv of : in ([], [None], None)
                                                  params = [];
                                                }
                                                else {
                                                  params = Object.keys(blocks.trialList[0]);
                                                }
                                              
                                                // save data for this loop
                                                thisExp.loopEnded(blocks);
                                                return psychoJS.NEXT;
                                                }
                                              
                                              function run() {
                                                // init psychoJS and set up OpenGL Canvas
                                                setupWin();
                                                psychoJS.init(win);
                                                
                                                // main scheduler
                                                scheduler = new psychoJS.Scheduler();
                                                
                                                // Store info about the experiment session
                                                expName = 'stroop';  // from the Builder filename that created this script
                                                expInfo = {'participant':'', 'session':'01'};
								expInfo = run_replace_default_expInfo();
								after_scheduleInstantiation();

                                                
                                                // set up experiment
                                                scheduler.add(setupExperiment);
                                                scheduler.add(psychoJS.setupCallbacks);
                                                
                                                // register all available resources and download them
                                                resourceScheduler = new psychoJS.Scheduler();
                                                resourceScheduler.add(registerResources);
                                                resourceScheduler.add(downloadResources);
                                                // asynchronous approach: the resource scheduler is run in parallel to the main one
                                                scheduler.add(function() { resourceScheduler.start(win); });
                                                
                                                // dialog box
                                                scheduler.add(psychoJS.gui.DlgFromDict({dictionary:expInfo, title:expName}));
                                                
                                                flowScheduler = new psychoJS.Scheduler();
                                                dialogCancelScheduler = new psychoJS.Scheduler();
                                                scheduler.addConditionalBranches(function() { return psychoJS.gui.dialogComponent.button === 'OK'; }, flowScheduler, dialogCancelScheduler);
                                                
                                                // flowScheduler gets run if the participants presses OK
                                                flowScheduler.add(updateInfo); // add timeStamp
                                                flowScheduler.add(experimentInit);
                                                flowScheduler.add(beginRoutineRoutineBegin);
                                                flowScheduler.add(beginRoutineRoutineEachFrame);
                                                flowScheduler.add(beginRoutineRoutineEnd);
                                                flowScheduler.add(fMRI_pauseRoutineBegin);
                                                flowScheduler.add(fMRI_pauseRoutineEachFrame);
                                                flowScheduler.add(fMRI_pauseRoutineEnd);
                                                instructionLoopLoopScheduler = new psychoJS.Scheduler();
                                                flowScheduler.add(instructionLoopLoopBegin, instructionLoopLoopScheduler);
                                                flowScheduler.add(instructionLoopLoopScheduler);
                                                flowScheduler.add(instructionLoopLoopEnd);
                                                blocksLoopScheduler = new psychoJS.Scheduler();
                                                flowScheduler.add(blocksLoopBegin, blocksLoopScheduler);
                                                flowScheduler.add(blocksLoopScheduler);
                                                flowScheduler.add(blocksLoopEnd);
                                                flowScheduler.add(finish_screenRoutineBegin);
                                                flowScheduler.add(finish_screenRoutineEachFrame);
                                                flowScheduler.add(finish_screenRoutineEnd);
                                                flowScheduler.add(quitPsychoJS);
                                                
                                                // quit if user presses Cancel in dialog box:
                                                dialogCancelScheduler.add(quitPsychoJS);
                                                
                                                scheduler.start(win);
                                              }
                                              
                                              function abbrevNames(thisTrial) {
                                                return function () {
                                                  // abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
                                                  if (thisTrial != undefined) {
                                                    for (paramName in thisTrial) {
                                                      window[paramName] = thisTrial[paramName];
                                                    }
                                                  }
                                                  return psychoJS.NEXT;
                                                };
                                              }
                                              
                                              function recordLoopIteration(currentLoop) {
                                                return function () {
                                                  currentLoop.updateAttributesAtBegin();
                                                  thisExp.nextEntry();
                                                  return psychoJS.NEXT;
                                                }
                                              }
                                              
                                              function quitPsychoJS() {
                                                  thisExp.save();
                                                  win.close()
                                                  psychoJS.core.quit();
                                                  return psychoJS.QUIT;
                                              }

        run();
      });
    </script>

  </body>
</html>
